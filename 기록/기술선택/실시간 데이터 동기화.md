## 실시간 데이터 동기화 시스템 (SSE 방식)

### 1. 시스템 개요

사용자의 실시간 상태(음악 재생, 펫 위치)를 팔로워들에게 실시간으로 전송하기 위해 **HTTP POST(상태 업데이트)** 와 **SSE(상태 수신)** 기술을 결합하여 사용합니다.

### 2. 데이터 흐름 (Data Flow)

1. **Host (공유자)**: 음악 재생 상태 변경(Play/Pause, 곡 변경)이나 펫 이동 발생 시 서버 API로 데이터를 전송합니다.
2. **Server**: 전달받은 데이터를 DB에 기록하고, 해당 사용자를 팔로우 중인 친구들의 SSE 채널로 데이터를 브로드캐스팅합니다.
3. **Guest (청취자/목격자)**: 서버로부터 전달받은 SSE 이벤트를 통해 즉시 UI(음악 플레이어, 캔버스)를 업데이트합니다.

---

### 3. 상세 프로토콜 설계

#### A. Host → Server (상태 업데이트 API 예시)

* **Endpoint**: `POST /api/v1/me/status`
* **Payload 예시**:

```json
{
  "music": {
    "musicId": "spotify:track:4cOdS6Jb",
    "isPlaying": true,
    "progressMs": 45000 // 현재 재생 지점 (ms)
  },
  "pet": {
    "x": 120.5,
    "y": 300.2,
    "action": "WALKING"
  }
}

```

#### B. Server → Guest (SSE 스트림)

* **Endpoint**: `GET /api/social/stream`
* **Event Types**:
* `MUSIC_UPDATE`: 친구의 음악 재생 정보 업데이트
* `PET_MOVE`: 친구 펫의 좌표/상태 정보 업데이트
* `FRIEND_ONLINE`: 친구 접속 알림

---

### 4. 핵심 동기화 로직

#### 🎵 음악 동기화 (Latency 보정)

친구와 음악 시간을 맞출 때 네트워크 지연(Latency)을 고려해야 합니다.

* **계산식**: `내 재생 시간 = 친구의 progressMs + (현재 시각 - 서버 전송 시각)`
* 이렇게 하면 친구와 나의 음악 재생 지점을 1초 미만의 오차로 맞출 수 있습니다.

#### 🐾 캔버스 펫 이동 (Interpolation)

SSE는 좌표를 초당 수십 번 보내기에 적합하지 않으므로, **보간법**을 사용합니다.

1. 서버에서 `targetX`, `targetY`만 받습니다.
2. 프론트엔드(Framer Motion)에서 `transition: { duration: 1 }`을 주어 현재 위치에서 목적지까지 부드럽게 이동시킵니다.

---

### 5. SSE vs WebSocket 채택 이유 (결론)

| 항목 | SSE (선택됨) | WebSocket |
| --- | --- | --- |
| **적합성** | 상태 구독 및 일방적 알림에 최적 | 채팅 등 빈번한 양방향 통신에 최적 |
| **구현 비용** | 표준 HTTP 사용으로 매우 낮음 | 전용 서버 및 프로토콜 관리 필요 |
| **안정성** | **자동 재연결** 지원으로 관리가 쉬움 | 재연결 로직 직접 구현 필요 |
| **리소스** | 서버 커넥션 유지 비용이 낮음 | 양방향 유지로 인해 비교적 높음 |

---

### 6. 다음 구현 단계 (Roadmap)

1. **[Backend]** SSE 전용 엔드포인트 구축 및 사용자별 이벤트 큐 생성.
2. **[Frontend]** `useSSE` 커스텀 훅을 만들어 `EventSource` 연결 관리.
3. **[Global State]** SSE로 받은 데이터를 **Zustand** 스토어에 저장하여 캔버스/플레이어 컴포넌트와 연결.
